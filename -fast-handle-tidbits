# -*- mode: sh; sh-indentation: 4; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
# Copyright (c) 2018 Sebastian Gniazdowski

emulate -LR zsh
setopt typesetsilent extendedglob noshortloops localtraps promptsubst noksharrays

typeset -gi __fshtb_call_count __fshtb_restart __fsh_x __fsh_y __fsh_trap_ran
typeset -g __fshtb_model __cur_line __fshtb_cur_tidbit
typeset -ga __fshtb_cur_keys __fshtb_cur_meta

(( __fshtb_call_count ++ ))
trap '(( __fshtb_call_count -- )); return 0;' INT

local -a color
color=( red green blue yellow cyan magenta black white )
local -a styles needles

# Uses:
# - array `styles', indexed by $3
# - hash `out' addressed by strings from `styles'
# - integer `offset', added to each final highlighting index
#
# Input:
# $1 - start_idx, 1-based (normally it's 0-based)
# $2 - end_idx, 1-based
# $3 - index of style, in `styles' upper-scope array
#
# Output:
# $FSH_LIST - array with ready to use region_highlight entries
-fsh_sy_h_shappend_ex3() {
    local ent
    ent="$(( $1 - 1 )) $2 $3"
    FSH_LIST+=( "$(( offset + ${${(s: :)ent}[1]} )) $(( offset + ${${(s: :)ent}[2]} )) ${out[<style>_${styles[${${(s: :)ent}[3]}]}]}" )
}

functions -M fsh_sy_h_append_ex3 3 3 -fsh_sy_h_shappend_ex3 2>/dev/null

# Needs arrays styles & needles to be set
function -fsh_add_highlights {
    local val="$1" cur_len="$2" ent
    integer idx

    FSH_LIST=()
    for (( idx=1; idx <= 2; ++ idx )); do
    : ${val//(#m)${needles[idx]}[^${needles[idx]}]#${needles[idx]}/$(( fsh_sy_h_append_ex3(cur_len+MBEGIN+1-1,cur_len+MEND-1-1,idx) ))}
    done
    REPLY="${val//(#b)[${(j::)needles}]([^${(j::)needles}]#)[${(j::)needles}]/${match[1]}}"

    # Highlight various quotations, wrappings with e.g. *.
    # It removes some bits of text, so should be run as
    # first highlighting code.
    integer formatting_offset=0
    for ent in "${(on)FSH_LIST[@]}"; do
        COLORS+=( "$(( ${${(s: :)ent}[1]} - formatting_offset )) $(( ${${(s: :)ent}[2]} - formatting_offset )) ${${(s: :)ent}[3]}" )
        formatting_offset+=2
    done
}

function -fsh_tidbits_main {
    if [[ "$__fshtb_call_count" -eq 1 || "$__fshtb_restart" -eq 1 ]]; then
        __fsh_x=1 __fsh_y=1
        __fshtb_cur_tidbit="" __fshtb_cur_keys=() __fshtb_cur_meta=()
        local update_xy=0
    else
        local update_xy=1
    fi

    [[ ! -f "$FAST_BASE_DIR"/tidbits/"$active_command".ini ]] && return 0
    [[ ! -r "$FAST_BASE_DIR"/tidbits/"$active_command".ini ]] && \
        print -u2 "Tidbit for $active_command unreadable, aborting." && return 0

    integer offset=${#BUFFER}

    # Load tidbits
    local -A out
    fast-read-ini-file "$FAST_BASE_DIR/tidbits/${active_command}.ini" out ""
    local tidbit key val meta ent tmp

    integer last_direction=0
    [[ "$update_xy" = 1 ]] && {
        [[ "$WIDGET" = *-handle-tidbits ]] && { __fsh_y+=1; last_direction=2; }
        [[ "$WIDGET" = *-backwards ]] && { (( __fsh_y =  (__fsh_y > 1) ? __fsh_y-1 : 1 )); last_direction=-2; }
        [[ "$WIDGET" = *-left ]] && { (( __fsh_x = (__fsh_x > 1) ? __fsh_x-1 : 1 )); last_direction=-1; }
        [[ "$WIDGET" = *-right ]] && { __fsh_x+=1; last_direction=1; }

        tmp=${#${(@s,;,)out[<meta>_order]}}
        (( __fsh_y > tmp )) && __fsh_y=tmp
    }

    # Normalize styles
    for key in ${out[(I)<style>_*]}; do
        ent="${out[$key]}"

        [[ "$ent" = bg:* ]] && out[$key]="bg=${ent#bg:}" || { \
            [[ "$ent" = (${(~j:|:)color})* || "$ent" = [0-9]##* ]] && out[$key]="fg="${ent}
        }
    done

    # Generate interface
    local -a entries keys templ_bits COLORS
    local -A hsh
    local template_line layout_theme nul=$'\0' padding_str
    integer idx=0 idx2 cur_len size padding
    __fshtb_model=$'\n' __cur_line=""
    for tidbit in "${(@s,;,)out[<meta>_order]}"; do
        hsh=( ${(kv)out[(I)<${(q)tidbit}>_*]} )  # whole ${tidbit} section, all entries
        entries=( ${(k)hsh} )
        entries=( /(e:'reply=($entries)':oe:'REPLY=${hsh[${REPLY}]}':) )  # keys sorted on values

        layout_theme="${out[<style>_layout-theme]}"
        idx+=1
        if (( idx == __fsh_y )); then
            if [[ "$tidbit" != \#* ]]; then
                template_line="${out[<theme-$layout_theme>_cursor-at-combo]}"
            else
                template_line="${out[<theme-$layout_theme>_cursor-at-option]}"
            fi

            # Also prepare outcome in case of ^M
            __fshtb_cur_tidbit="$tidbit"
            __fshtb_cur_keys=( "${entries[@]}" )
            __fshtb_cur_meta=()
            for key in "${__fshtb_cur_keys[@]}"; do
                meta="${out[$key]}"
                meta="${(M)meta#[A-Z][0-9](#c1,2)}"
                __fshtb_cur_meta+=( "$meta" )
            done
        else
            if [[ "$tidbit" != \#* ]]; then
                template_line="${out[<theme-$layout_theme>_regular-combo]}"
            else
                template_line="${out[<theme-$layout_theme>_regular-option]}"
            fi
        fi

        templ_bits=( "${(@Q)${(z@)template_line}}" )

        local tbit idx_from idx_to isepar=":" separ code LAST=${#entries} content_added=0 first=1
        local stra stracol strb strbcol
        for tbit in "${templ_bits[@]}"; do
            if [[ "$tbit" = (#b)"%opt["([^\],]#)","([^\]]#)\]\[([^\]]#)\](#B)(\((#b)([^\),]#)","(#c0,1)([^\)]#)\))(#c0,1)(#B)(\{(#b)([^\}]#)\})(#c0,1) ]]; then
                idx_from="${match[1]}" idx_to="${match[2]}" separ="${match[3]}" stra="${match[4]}" strb="${match[5]}"
                code="${match[6]}"

                [[ "$stra" = (#b)(*)/(*) ]] && stra="${match[1]}" stracol="${match[2]}"
                [[ "$strb" = (#b)(*)/(*) ]] && strb="${match[1]}" strbcol="${match[2]}"

                tmp="$separ"
                for (( idx2 = idx_from; idx2 <= idx_to && idx2 <= LAST; ++ idx2 )); do
                    (( idx2 == idx_to || idx2 == LAST )) && tmp=""

                    # stra
                    if [[ -n "$stra" ]]; then
                        [[ -n "$stracol" ]] && COLORS+=( "$(( offset + ${#__fshtb_model} )) $(( offset + ${#__fshtb_model} + ${#stra} )) fg=$stracol" )
                        __fshtb_model+="$stra"
                        if (( first )); then
                            (( idx == __fsh_y )) && __cur_line+="$stra"
                        else
                            (( idx == __fsh_y )) && __cur_line+=$'\0'"$stra"
                        fi
                        first=0
                    fi


                    # The option text
                    ent=${entries[idx2]}
                    key="${${ent#<[^>]##>_}/_/ }"
                    COLORS+=( "$(( offset + ${#__fshtb_model} )) $(( offset + ${#__fshtb_model} + ${#key} )) ${out[<style>_option]}" )
                    __fshtb_model+="$key"
                    if (( first )) || [[ -n "$stra" ]]; then
                        (( idx == __fsh_y )) && __cur_line+="$key"
                    else
                        (( idx == __fsh_y )) && __cur_line+=$'\0'"$key"
                    fi
                    first=0

                    # Strb
                    if [[ -n "$strb" ]]; then
                        [[ -n "$strbcol" ]] && COLORS+=( "$(( offset + ${#__fshtb_model} )) $(( offset + ${#__fshtb_model} + ${#strb} )) fg=$strbcol" )
                        __fshtb_model+="$strb"
                        (( idx == __fsh_y )) && __cur_line+="$strb"
                    fi

                    __fshtb_model+="$tmp"
                    (( idx == __fsh_y )) && __cur_line+="${tmp:+$nul$tmp}"

                    content_added=1
                done
            elif [[ "$tbit" = (#b)"%desc["([^\],]#)","([^\]]#)\]\[([^\]]#)\](#B)(\((#b)([^\),]#)","(#c0,1)([^\)]#)\))(#c0,1)(#B)(\{(#b)([^\}]#)\})(#c0,1) ]]; then
                idx_from="${match[1]}" idx_to="${match[2]}" separ="${match[3]}" stra="${match[4]}" strb="${match[5]}"
                code="${match[6]}"

                [[ "$stra" = (#b)(*)/(*) ]] && stra="${match[1]}" stracol="${match[2]}"
                [[ "$strb" = (#b)(*)/(*) ]] && strb="${match[1]}" strbcol="${match[2]}"

                tmp="$separ"
                # Used by -fsh_add_highlights
                styles=( star-quoted double-quoted )
                needles=( "*" "\"" )

                for (( idx2 = idx_from; idx2 <= idx_to && idx2 <= LAST; ++ idx2 )); do
                    (( idx2 == idx_to || idx2 == LAST )) && tmp=""

                    # stra
                    if [[ -n "$stra" ]]; then
                        [[ -n "$stracol" ]] && COLORS+=( "$(( offset + ${#__fshtb_model} )) $(( offset + ${#__fshtb_model} + ${#stra} )) fg=$stracol" )
                        __fshtb_model+="$stra"
                        if (( first )); then
                            (( idx == __fsh_y )) && __cur_line+="$stra"
                        else
                            (( idx == __fsh_y )) && __cur_line+=$'\0'"$stra"
                        fi
                        first=0
                    fi

                    # The description text
                    ent=${entries[idx2]}

                    # Highlights of "..." and *...*
                    val="${hsh[$ent]#[A-Z][0-9](#c1,2)}"
                    -fsh_add_highlights "$val" "${#__fshtb_model}"
                    val="$REPLY"

                    __fshtb_model+="$val"
                    if (( first )) || [[ -n "$stra" ]]; then
                        (( idx == __fsh_y )) && __cur_line+="$val"
                    else
                        (( idx == __fsh_y )) && __cur_line+=$'\0'"$val"
                    fi
                    first=0

                    # Strb
                    if [[ -n "$strb" ]]; then
                        [[ -n "$strbcol" ]] && COLORS+=( "$(( offset + ${#__fshtb_model} )) $(( offset + ${#__fshtb_model} + ${#strb} )) fg=$strbcol" )
                        __fshtb_model+="$strb"
                        (( idx == __fsh_y )) && __cur_line+="$strb"
                    fi

                    __fshtb_model+="$tmp"
                    (( idx == __fsh_y )) && __cur_line+="${tmp:+$nul$tmp}"

                    content_added=1
                done
            elif [[ "$tbit" = (#b)"%optdesc["([^\],]#)","([^\]]#)\](\<([^\>]#)\>)(#c0,1)\[([^\]]#)\](#B)(\((#b)([^\),]#)","(#c0,1)([^\)]#)\))(#c0,1)(#B)(\{(#b)([^\}]#)\})(#c0,1) ]]; then
                idx_from="${match[1]}" idx_to="${match[2]}" isepar="${match[4]:-:}" separ="${match[5]}" stra="${match[6]}" strb="${match[7]}" code="${match[8]}"

                [[ "$stra" = (#b)(*)/(*) ]] && stra="${match[1]}" stracol="${match[2]}"
                [[ "$strb" = (#b)(*)/(*) ]] && strb="${match[1]}" strbcol="${match[2]}"

                tmp="$separ"
                # Used by -fsh_add_highlights
                styles=( star-quoted double-quoted )
                needles=( "*" "\"" )

                for (( idx2 = idx_from; idx2 <= idx_to && idx2 <= LAST; ++ idx2 )); do
                    (( idx2 == idx_to || idx2 == LAST )) && tmp=""

                    # stra
                    if [[ -n "$stra" ]]; then
                        [[ -n "$stracol" ]] && COLORS+=( "$(( offset + ${#__fshtb_model} )) $(( offset + ${#__fshtb_model} + ${#stra} )) fg=$stracol" )
                        __fshtb_model+="$stra"
                        if (( first )); then
                            (( idx == __fsh_y )) && __cur_line+="$stra"
                        else
                            (( idx == __fsh_y )) && __cur_line+=$'\0'"$stra"
                        fi
                        first=0
                    fi

                    ent=${entries[idx2]}
                    key="${${ent#<[^>]##>_}/_/ }"
                    val="${hsh[$ent]#[A-Z][0-9](#c1,2)}"
                    -fsh_add_highlights "$val" "$(( ${#key} + ${#isepar} + ${#__fshtb_model} ))"
                    val="$REPLY"

                    __fshtb_model+="$key$isepar$val"
                    if (( first )); then
                        (( idx == __fsh_y )) && __cur_line+="$key$nul$isepar$nul$val"
                    else
                        (( idx == __fsh_y )) && __cur_line+=$'\0'"$key$nul$isepar$nul$val"
                    fi
                    first=0

                    # Strb
                    if [[ -n "$strb" ]]; then
                        [[ -n "$strbcol" ]] && COLORS+=( "$(( offset + ${#__fshtb_model} )) $(( offset + ${#__fshtb_model} + ${#strb} )) fg=$strbcol" )
                        print "Added color at: |$__fshtb_model|" >> /tmp/reply
                        __fshtb_model+="$strb"
                        (( idx == __fsh_y )) && __cur_line+="$strb"
                    fi

                    __fshtb_model+="$tmp"
                    (( idx == __fsh_y )) && __cur_line+="${tmp:+$nul$tmp}"

                    content_added=1
                done
            elif [[ "$tbit" = (#b)"%item-id"(#B)(\((#b)([^/\),]#)/(#c0,1)([^,\)]#)","([^/\)]#)/(#c0,1)([^\)]#)\))(#c0,1) ]]; then
                stra="${match[1]}" stracol="${match[2]}" strb="${match[3]}" strbcol="${match[4]}"
                __fshtb_model+="${stra}$tidbit${strb}"
                if (( first )); then
                    (( idx == __fsh_y )) && __cur_line+="${stra}$tidbit${strb}"
                else
                    (( idx == __fsh_y )) && __cur_line+=$'\0'"${stra}$tidbit${strb}"
                fi
                first=0
                content_added=1
            elif [[ "$tbit" = "%END" ]]; then
                content_added=0
                break
            else
                if (( content_added )); then
                    if [[ "$tbit" = (#b)*\{([0-9]#)\} ]]; then
                        padding="${match[1]}"
                        tbit=${tbit%\{[0-9]#\}}
                        if [[ "$__fshtb_model" = (#b)*($'\n'|(#s))(*)(#e) ]]; then
                            padding=padding-${#match[2]}
                            (( padding <= 0 )) && padding=0
                        fi
                    else
                        padding=0
                    fi
                    (( padding > 0 )) && padding_str="${(l:padding:):-}" || padding_str=""
                    [[ "$tbit" = "+"* ]] && { __fshtb_model+="$padding_str ${tbit#+} "; (( idx == __fsh_y )) && __cur_line+=$'\0'"$padding_str ${tbit#+} "; }
                    [[ "$tbit" != "+"* ]] && { __fshtb_model+="$padding_str$tbit"; (( idx == __fsh_y )) && __cur_line+=$'\0'"$padding_str$tbit"; }
                    content_added=0
                fi
            fi
        done
        __fshtb_model+=$'\n'
        (( idx == __fsh_y )) && __cur_line+=$'\n'
    done

    region_highlight=()

    # Highlight combo and option identifiers
    styles=( combo-id opt-id )
    needles=( "\[[^#][^\]]##\]##" "\[[#][^\]]##\]##" )

    FSH_LIST=()
    for (( idx=1; idx <= 2; ++ idx )); do
        : ${__fshtb_model//(#m)${~needles[idx]}/$(( fsh_sy_h_append_ex3(MBEGIN,MEND,idx) ))}
    done
    region_highlight+=( "${FSH_LIST[@]}" )

    # Highlights aggregated in generation code
    region_highlight+=( "${COLORS[@]}" )

    POSTDISPLAY="${__fshtb_model}"

    __fshtb_model="${__fshtb_model#$'\n'}"

    # Cursor
    local -a lines columns
    lines=( "${(f)__fshtb_model[@]}" )
    integer ysize=${#lines} xsize
    (( __fsh_y > ysize )) && __fsh_y=ysize
    (( __fsh_y <= 0 )) && __fsh_y=1
    columns=( "${(0)__cur_line[@]}" )
    xsize=${#columns}
    (( __fsh_x > xsize )) && __fsh_x=xsize
    (( __fsh_x <= 0 )) && __fsh_x=1

    integer offset2=0 offset3=0 idx=0

    for (( idx = 1; idx < __fsh_y; ++ idx )); do
        offset2+=${#lines[idx]}+1
    done
    offset3=offset2
    for (( idx = 1; idx < __fsh_x; ++ idx )); do
        offset2+=${#columns[idx]}
    done
    if (( last_direction == 1 && __fsh_x < xsize )); then
        if [[ "${columns[idx]}" != *[a-zA-Z0-9]* ]]; then
            __fsh_x+=1
            offset2+=${#columns[idx]}
            idx+=1
        fi
    elif (( last_direction == -1 && __fsh_x > 1 )); then
        if [[ "${columns[idx]}" != *[a-zA-Z0-9]* ]]; then
            __fsh_x=__fsh_x-1
            offset2=offset2-${#columns[idx-1]}
            idx=idx-1
        fi
    fi

    region_highlight+=( "$(( offset + offset3 )) $(( offset + offset3 + ${#lines[__fsh_y]} + 1 )) ${out[<style>_cursorwide]}" )
    region_highlight+=( "$(( offset + offset2 )) $(( offset + offset2 + ${#columns[idx]} + 1 )) ${out[<style>_cursor]}" )
}

-fsh_tidbits_main

_fshtb_simulate_widget() {
    (( __fshtb_call_count ++ ))
    -fsh_tidbits_main
}

_fshtb_self_insert() {
    LBUFFER+="${KEYS[-1]}"
    __fshtb_restart="1"
    _fshtb_simulate_widget
}

_fshtb_backward_delete_char() {
    LBUFFER="${LBUFFER%?}"
    __fshtb_restart="1"
    _fshtb_simulate_widget
}

_fshtb_delete_char() {
    RBUFFER="${RBUFFER#?}"
    __fshtb_restart="1"
    _fshtb_simulate_widget
}

-fshtb_backward_kill_word() {
    builtin zle .backward-kill-word
    __fshtb_restart="1"
    _fshtb_simulate_widget
}

if [[ "$__fshtb_call_count" -eq 1 ]]; then
    bindkey -N fshtb emacs

    local down_widget="-fast-handle-tidbits" up_widget="-fast-handle-tidbits-backwards"
    local left_widget="-fast-handle-tidbits-left" right_widget="-fast-handle-tidbits-right"

    # Manual, termcap, terminfo
    bindkey -M fshtb '^[OA' "$up_widget"
    bindkey -M fshtb '^[OB' "$down_widget"
    bindkey -M fshtb '^[OD' "$left_widget"
    bindkey -M fshtb '^[OC' "$right_widget"
    bindkey -M fshtb '^[[A' "$up_widget"
    bindkey -M fshtb '^[[B' "$down_widget"
    bindkey -M fshtb '^[[D' "$left_widget"
    bindkey -M fshtb '^[[C' "$right_widget"
    [[ -n "$termcap[ku]" ]] && bindkey -M fshtb "$termcap[ku]" "$up_widget"
    [[ -n "$termcap[kd]" ]] && bindkey -M fshtb "$termcap[kd]" "$down_widget"
    [[ -n "$termcap[kl]" ]] && bindkey -M fshtb "$termcap[ku]" "$left_widget"
    [[ -n "$termcap[kr]" ]] && bindkey -M fshtb "$termcap[kd]" "$hown_widget"
    [[ -n "$termcap[kD]" ]] && bindkey -M fshtb "$termcap[kD]" .delete-char
    [[ -n "$terminfo[kcuu1]" ]] && bindkey -M fshtb "$terminfo[kcuu1]" "$up_widget"
    [[ -n "$terminfo[kcud1]" ]] && bindkey -M fshtb "$terminfo[kcud1]" "$down_widget"
    [[ -n "$terminfo[kcub1]" ]] && bindkey -M fshtb "$terminfo[kcuu1]" "$left_widget"
    [[ -n "$terminfo[kcuf1]" ]] && bindkey -M fshtb "$terminfo[kcud1]" "$right_widget"
    [[ -n "$terminfo[kdch1]" ]] && bindkey -M fshtb "$terminfo[kdch1]" .delete-char

    # More bindkeys, to remove influence of plugins that overload things (z-sy-h, z-au-s)
    #bindkey -M fshtb '^[[D' .backward-char
    #bindkey -M fshtb '^[[C' .forward-char
    [[ -n "$termcap[kl]" ]] && bindkey -M fshtb "$termcap[kl]" .backward-char
    [[ -n "$termcap[kr]" ]] && bindkey -M fshtb "$termcap[kr]" .forward-char
    [[ -n "$terminfo[kcub1]" ]] && bindkey -M fshtb "$terminfo[kcub1]" .backward-char
    [[ -n "$terminfo[kcuf1]" ]] && bindkey -M fshtb "$terminfo[kcuf1]" .forward-char

    [[ -n "$termcap[kh]" ]] && bindkey -M fshtb "$termcap[kh]" .beginning-of-line
    [[ -n "$termcap[@7]" ]] && bindkey -M fshtb "$termcap[@7]" .end-of-line
    [[ -n "$terminfo[khome]" ]] && bindkey -M fshtb "$terminfo[khome]" .beginning-of-line
    [[ -n "$terminfo[kend]" ]] && bindkey -M fshtb "$terminfo[kend]" .end-of-line
    bindkey -M fshtb '^A' .beginning-of-line
    bindkey -M fshtb '^E' .end-of-line
    bindkey -M fshtb '^R' "$down_widget"

    # Needed for Fedora 23, zsh-5.1.1
    bindkey -M fshtb ' ' self-insert

    # Substitute self-insert, backward-delete-char, delete-char
    zle -A self-insert fshtb-saved-self-insert
    zle -A backward-delete-char fshtb-saved-backward-delete-char
    zle -A delete-char fshtb-saved-delete-char
    zle -N self-insert _fshtb_self_insert
    zle -N backward-delete-char _fshtb_backward_delete_char
    zle -N delete-char _fshtb_delete_char
    zle -N -- -fshtb_backward_kill_word
    bindkey -M fshtb -- '^W' -fshtb_backward_kill_word

    # OMZ does funny things with zle-keymap-select
    zle -la zle-keymap-select && {
        zle -A zle-keymap-select fshtb-saved-zle-keymap-select
        zle -D zle-keymap-select
    }

    # Override ourselves with what we actually are
    # because zsh-autosuggestions change us
    zle -A -- "$down_widget" fshtb-saved-"$down_widget"
    zle -A -- "$up_widget" fshtb-saved-"$up_widget"
    zle -A -- "$left_widget" fshtb-saved-"$left_widget"
    zle -A -- "$right_widget" fshtb-saved-"$right_widget"
    zle -N -- "$down_widget" _fshtb_simulate_widget
    zle -N -- "$up_widget" _fshtb_simulate_widget
    zle -N -- "$left_widget" _fshtb_simulate_widget
    zle -N -- "$right_widget" _fshtb_simulate_widget

    __fsh_trap_ran=0
    trap '(( __fsh_trap_ran == 0 )) && zle && { __fsh_trap_ran=1; zle .send-break; }' INT

    if zle .recursive-edit -K fshtb; then
        trap '' INT
        POSTDISPLAY=""
        -fast-insert-options
    else
        trap '' INT
        POSTDISPLAY=""
    fi

    # Restore self-insert, backward-delete-char, delete-char
    zle -A fshtb-saved-self-insert self-insert
    zle -A fshtb-saved-backward-delete-char backward-delete-char
    zle -A fshtb-saved-delete-char delete-char
    zle -D fshtb-saved-self-insert fshtb-saved-backward-delete-char fshtb-saved-delete-char
    zle -la fshtb-saved-zle-keymap-select && {
        zle -A fshtb-saved-zle-keymap-select zle-keymap-select
        zle -D fshtb-saved-zle-keymap-select
    }

    # Restore ourselves
    zle -A fshtb-saved-"$down_widget" "$down_widget"
    zle -A fshtb-saved-"$up_widget" "$up_widget"
    zle -A fshtb-saved-"$left_widget" "$left_widget"
    zle -A fshtb-saved-"$right_widget" "$right_widget"
    zle -D fshtb-saved-"$down_widget" fshtb-saved-"$up_widget" fshtb-saved-"$left_widget" fshtb-saved-"$right_widget"

    # Full reinitialisation at next call
    __fshtb_call_count="0"

elif (( __fshtb_call_count > 0 )); then
    (( __fshtb_call_count -- ))
fi

# vim:ft=zsh:et:sw=4
